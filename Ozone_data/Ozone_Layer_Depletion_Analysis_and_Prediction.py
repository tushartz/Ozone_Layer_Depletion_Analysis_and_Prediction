# -*- coding: utf-8 -*-
"""new_oz_data (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ahc-IuO4tU_ClVK6xg_NkUi_qSM5sLyZ

# OZONE LAYER DEPLETION ANALYSIS AND PREDICTION USING FB PROPHET

# Plan of Attack
 

1. Introduction and Installation
2. Data Cleaning
3. Plotting Dataframe
3. Model Fitting
4. Making Future Predictions
5. Obtaining the Forecasts
6. Plotting the Forecasts
6. Plotting the Forecast Components
7. Cross Validation
8. Obtaining the Performance Metrics
9. Visualizing Performance Metrics

# 1. Introduction and Installation

There are very many open source forecastings tools, however none of these would be fit to solve all forecasting problems. Prophet works best with hourly, and weekly data that is several months. When working with Prophet yearly data is most prefered.

Prophet can be installed using pip in Python as shown below. Prophet depends on a Python module called pystan. This module will be installed automatically as we install Prophet.
"""

pip install fbprophet

"""importing Pandas, Numpy, matplotlib for data manipulation, plotings and Prophet for forecasting. 

Next we load in our dataset and check its preview from head.


"""

import pandas as pd
import numpy as np
import fbprophet
import matplotlib.pyplot as plt

df = pd.read_csv('Ozone_data_updated2.csv',parse_dates=True,squeeze=True)

"""# 2. Data Cleaning"""

df.head()

"""Now, as we see many missing values in the data in the form, of '?' we need to replace it with NAN values """

df.replace({'?':np.nan}, inplace=True)

df.head()

"""Now replace the NAN values with Forward fill (ffill)"""

df = df.fillna(method= 'ffill').copy()

df.head()

""" Converting the values in numeric form"""

df['0-700du'] = pd.to_numeric(df['0-700du'],errors='coerce')

"""# 3. Ploting Dataframe

**PLOTING THE DATAFRAME CAN SHOW THE SCENARIO OF DATA WHICH IS IN STATIONARY OR NON STATIONARY FORM**
**AS WE SEE THE GRAPH, IT INDICATES THAT DATA IS NON STATIONARY**
"""

df.plot()

"""Prophet expects the dataset to have two columns named as ds and y. ds is the date column while y is the column that we are forecasting"""

df1 = df[[ 'date', '0-700du']]

df1.head()

df1.columns

df1.columns = ["ds", "y"]

df1['ds']=pd.to_datetime(df1['ds'])

df1.head()

df1.describe()

df1.columns

plt.figure(figsize=(10,6))
plt.plot(df1.set_index('ds'))
plt.legend(['y'])

"""# 4. Model Fitting

We start by creating an instance of the Prophet class and then fit it to our dataset.
"""

from fbprophet import Prophet

model = Prophet()

model.fit(df1)

"""# 5. Making Future Predictions

The next step is to prepare our model to make future predictions.



This is achieved using the Prophet.make_future_dataframe method and passing the number of days we’d like to predict in the future. 

We use the periods attribute to specify this. This also include the historical dates. We’ll use these historical dates to compare the predictions with the actual values in the ds column.
"""

future_dates = model.make_future_dataframe(periods = 3650)

df1.tail()

future_dates

"""# 6. Obtaining the Forecasts

We use the predict method to make future predictions. 

This will generate a dataframe with a **yhat** column that will contain the predictions.
"""

prediction = model.predict(future_dates)

"""If we check the head for our forecast dataframe we’ll notice that it has very many columns. 

However, we are mainly interested in **ds, yhat, yhat_lower** and **yhat_upper**. 

**yhat** is our predicted forecast, **yhat_lower** is the lower bound for our predictions and **yhat_upper** is the upper bound for our predictions.
"""

prediction.head()

prediction[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

prediction[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head()

"""# 7. Plotting the Forecasts

Prophet has an inbuilt feature that enables us to plot the forecasts we just generated. 

This is achieved using model.plot() and passing in our forecasts as the argument. 

The blue line in the graph represents the predicted values while the black dots represents the data in our dataset.
"""

plot1=model.plot(prediction)

"""# 8. Plotting the Forecast Components

The plot_components method plots the trend, yearly and weekly seasonality of the time series data.
"""

plot2 = model.plot_components(prediction)

"""#9.  Cross Validation

Next We measure the forecast error using the historical data. We’ll do this by comparing the predicted values with the actual values. 

In order to perform this operation we select cut of points in the history of the data and fit the model with data upto that cut off point. Afterwards we compare the actual values to the predicted values. The cross_validation method allows us to do this in Prophet. 

This method take the following parameters as explained below:

1. horizon the forecast horizon
2. initial the size of the initial training period
3. period the spacing between cutoff dates


The output of the cross_validation method is a dataframe containing y the true values and yhat the predicted values. We’ll use this dataframe to compute the prediction errors.
"""

from fbprophet.diagnostics import cross_validation

df_cv = cross_validation(model, horizon = '3650 days', period = '1825 days', initial = '10950 days')

df_cv.head()

df_cv.tail()

"""# 10. Obtaining the Performance Metrics

We use the performance_metrics utility to compute the Mean Squared Error(MSE), Root Mean Squared Error(RMSE),Mean Absolute Error(MAE), Mean Absolute Percentage Error(MAPE) and the coverage of the the yhat_lower and yhat_upper estimates.
"""

from fbprophet.diagnostics import performance_metrics

df_performance = performance_metrics(df_cv)

df_performance

"""#11.  Visualizing Performance Metrics

The performance Metrics can be visualized using the plot_cross_validation_metric utility. 

Here we visualize the RMSE below.
"""

from fbprophet.plot import plot_cross_validation_metric

fig = plot_cross_validation_metric(df_cv, metric='rmse')